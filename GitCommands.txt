Perfect ğŸ‘
Hereâ€™s a **complete but clean Git + GitHub command cheat sheet** â€” from **beginner â†’ advanced**, organized so you can quickly revise before interviews or real work.

---

# ğŸ”¹ GIT vs GITHUB (1-line)

* **Git** â†’ version control tool (local)
* **GitHub** â†’ remote hosting platform for Git repositories

---

# ğŸ§± 1. BASIC SETUP (One time)

```bash
git --version
git config --global user.name "Your Name"
git config --global user.email "you@email.com"
git config --list
```

---

# ğŸ“ 2. CREATE / CLONE REPOSITORY

### Initialize new repo (local)

```bash
git init
```

### Clone existing GitHub repo

```bash
git clone https://github.com/user/repo.git
```

---

# ğŸ“Š 3. CHECK STATUS & HISTORY

```bash
git status
git log
git log --oneline
git log --stat
git show
```

---

# â• 4. STAGING (Add files)

```bash
git add file.txt
git add folder/
git add .
```

Unstage:

```bash
git restore --staged file.txt
```

---

# ğŸ’¾ 5. COMMIT

```bash
git commit -m "message"
git commit -am "message"   # tracked files only
```

Amend last commit:

```bash
git commit --amend
```

---

# ğŸ”„ 6. PUSH / PULL (Local â†” GitHub)

### Add remote

```bash
git remote add origin https://github.com/user/repo.git
```

### View remote

```bash
git remote -v
```

### Push

```bash
git push
git push origin main
git push -u origin main
```

### Pull

```bash
git pull
git pull origin main
git pull --rebase
```

### Fetch (no merge)

```bash
git fetch
```

---

# ğŸŒ¿ 7. BRANCHING

```bash
git branch              # list branches
git branch new-branch
git checkout new-branch
git checkout -b new-branch
git switch main
```

Delete branch:

```bash
git branch -d branch-name
git branch -D branch-name
```

Push branch:

```bash
git push origin branch-name
```

---

# ğŸ”€ 8. MERGING & REBASE

Merge:

```bash
git merge branch-name
```

Rebase:

```bash
git rebase main
```

Abort merge:

```bash
git merge --abort
```

---

# ğŸ§¨ 9. UNDO / RESET / REVERT (VERY IMPORTANT)

### Undo working directory changes

```bash
git restore file.txt
```

### Reset staged file

```bash
git reset file.txt
```

### Reset commits

```bash
git reset --soft HEAD~1
git reset --mixed HEAD~1
git reset --hard HEAD~1
```

### Revert commit (safe)

```bash
git revert commit_hash
```

---

# ğŸ” 10. DIFF & TRACE CHANGES

```bash
git diff
git diff --staged
git diff commit1 commit2
```

File history:

```bash
git log file.txt
```

Line by line:

```bash
git blame file.txt
git blame -L 10,20 file.txt
```

Search code change:

```bash
git log -S "text"
```

---

# ğŸ“‚ 11. FILE / FOLDER OPERATIONS

```bash
git rm file.txt
git rm -r folder/
git mv old.txt new.txt
```

---

# ğŸš« 12. .gitignore

```bash
touch .gitignore
```

Check ignored files:

```bash
git check-ignore -v file.txt
```

---

# ğŸ§³ 13. STASH (Temporary save)

```bash
git stash
git stash list
git stash apply
git stash pop
git stash drop
```

---

# ğŸ·ï¸ 14. TAGS (Releases)

```bash
git tag v1.0
git tag
git push origin v1.0
git push --tags
```

---

# ğŸ” 15. AUTHENTICATION (GitHub)

GitHub uses **PAT (token)** instead of password.

Check credentials:

```bash
git config --global --list
```

---

# ğŸ§  16. DAILY WORKFLOW (REMEMBER THIS)

```bash
git status
git add .
git commit -m "message"
git pull --rebase
git push
```

---

# ğŸ§ª 17. ADVANCED / RARE BUT USEFUL

```bash
git reflog
git cherry-pick commit_hash
git clean -fd
git bisect
```

---

# ğŸ“Œ INTERVIEW FAVORITES (MUST KNOW)

* `git add`
* `git commit`
* `git push`
* `git pull`
* `git merge`
* `git rebase`
* `git reset` vs `git revert`
* `git stash`
* `git blame`

---

If you want next:

* âœ… **Git commands explained with real-life analogy**
* âœ… **GitHub workflow (PR, fork, review)**
* âœ… **DevOps-focused Git usage**
* âœ… **One-page printable PDF**

Just tell me ğŸ‘
---------------------------------------------------------------------------



Great set of commands ğŸ‘
These are **very important Git concepts**. Iâ€™ll explain **what they do, when to use them, and one simple example each**.

---

# 1ï¸âƒ£ `git rebase`

## ğŸ”¹ What it does

`git rebase` **moves your commits on top of another branch** to create a **clean, straight history**.

ğŸ‘‰ It **replays your commits** as if they were made after the latest changes.

---

## ğŸ”¹ When to use

* To **update your branch with latest `main`**
* To avoid **extra merge commits**
* Before opening a **Pull Request**

---

## ğŸ”¹ Example

You are on `feature` branch:

```bash
git checkout feature
git rebase main
```

ğŸ“Œ Result:

```
main ---- A ---- B
                \
                 C' ---- D'
```

(`C` and `D` are replayed â†’ new commit hashes)

---

## âš ï¸ Rule (IMPORTANT)

âŒ Never rebase **shared/public branches**
âœ” Rebase only **your own local branches**

---

# 2ï¸âƒ£ `git reset` vs `git revert`

## ğŸ”´ `git reset` (rewrites history)

### ğŸ”¹ What it does

Moves the **HEAD pointer backward** and can **delete commits**.

---

### ğŸ”¹ Types

```bash
git reset --soft HEAD~1     # keep changes staged
git reset --mixed HEAD~1    # keep changes unstaged (default)
git reset --hard HEAD~1     # delete everything
```

### ğŸ”¹ Use when

* Mistakes in **local commits**
* Commit **not pushed yet**

---

## ğŸŸ¢ `git revert` (safe way)

### ğŸ”¹ What it does

Creates a **new commit that undoes a previous commit**.

```bash
git revert commit_hash
```

### ğŸ”¹ Use when

* Commit is **already pushed**
* Working in a **team**

---

### ğŸ§  Simple difference

| Reset           | Revert        |
| --------------- | ------------- |
| Deletes history | Keeps history |
| Dangerous       | Safe          |
| Local use       | Team use      |

---

# 3ï¸âƒ£ `git stash`

## ğŸ”¹ What it does

Temporarily **saves uncommitted changes** and gives you a **clean working directory**.

---

## ğŸ”¹ When to use

* Need to **switch branch quickly**
* Pull latest changes
* Donâ€™t want to commit yet

---

## ğŸ”¹ Commands

```bash
git stash          # save changes
git stash list     # view stashes
git stash apply    # apply stash (keeps stash)
git stash pop      # apply + delete stash
git stash drop     # delete stash
```

ğŸ“Œ Example:

```bash
git stash
git pull
git stash pop
```

---

# 4ï¸âƒ£ `git blame`

## ğŸ”¹ What it does

Shows **who changed each line**, **when**, and **which commit**.

---

## ğŸ”¹ When to use

* Debugging
* Understanding old code
* Asking the right person for clarification ğŸ˜„

---

## ğŸ”¹ Commands

```bash
git blame file.txt
git blame -L 10,20 file.txt
```

ğŸ“Œ Output shows:

* Author
* Commit hash
* Line number

---

# ğŸ”¥ Quick Summary (Interview-ready)

| Command      | Use                        |
| ------------ | -------------------------- |
| `git rebase` | Clean commit history       |
| `git reset`  | Undo local commits         |
| `git revert` | Undo pushed commits safely |
| `git stash`  | Temporarily save work      |
| `git blame`  | Track line-level changes   |

---

If you want next:

* âœ… real-life analogy (very easy to remember)
* âœ… diagrams for these commands
* âœ… interview answers in 2â€“3 lines
* âœ… DevOps use-cases

Just tell me ğŸ‘
--------------------------------------------------------------------


Good question ğŸ‘
This is **exactly how Git is meant to be used**. Iâ€™ll explain it **step-by-step**, very clearly.

---

## ğŸ“Œ Situation

* File already exists
* You **add more lines**
* `git status` shows:

```
modified: filename
```

---

## âœ… How to commit those changes

### 1ï¸âƒ£ Check what changed (optional but recommended)

```bash
git diff
```


to come back to local drive promp 
press q

ğŸ‘‰ Shows the **new lines you added**.

---

### 2ï¸âƒ£ Stage the modified file

You must **add it again** (even though it already exists).

```bash
git add filename
```

Or add all modified files:

```bash
git add .
```

ğŸ“Œ This tells Git:

> â€œI want to include these new changes in the next commitâ€

---

### 3ï¸âƒ£ Commit the changes

```bash
git commit -m "Added new lines to filename"
```

âœ” Now the new lines are saved in Git history.

---

### 4ï¸âƒ£ Push to GitHub (if linked)

```bash
git push
```

---

## ğŸ§  IMPORTANT CONCEPT (many beginners miss this)

### â“ Why do we run `git add` again?

Because:

* `git add` **stages changes**, not files
* Every time you modify a file, Git treats it as **new work**

Think like this:

> **Edit â†’ Add â†’ Commit â†’ Push**

Every time.

---

## ğŸ” Example flow

```bash
nano app.py      # or edit in VS Code
git status       # shows modified
git diff
git add app.py
git commit -m "Updated logic in app"
git push
```

---

## âš ï¸ Common mistakes

### âŒ Only commit without add

```bash
git commit -m "update"   # âŒ won't include new changes
```

### âŒ Forget push

Commit saves locally only.

---

## âœ… Shortcut (tracked files only)

```bash
git commit -am "Updated file"
```

âš ï¸ Works **only for already tracked files**.

---

## ğŸ”¥ One-line pro command

```bash
git add . && git commit -m "update" && git push
```

---

If you want next, I can show:

* âœ” committing **only selected lines**
* âœ” undoing a modified file
* âœ” splitting changes into multiple commits

Just tell me ğŸ‘
--------------------------------------------------------------------------------

